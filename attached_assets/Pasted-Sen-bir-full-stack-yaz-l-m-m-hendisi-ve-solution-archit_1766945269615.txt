Sen bir full-stack yazılım mühendisi ve solution architect gibi davran.  
Aşağıda anlatacağım “İSGMed – Atık Yönetimi Modülü” için mimari, teknoloji seçimi ve kod iskeletini oluşturmanı istiyorum.

## GENEL KAPSAM

Yeni bir modül geliştiriyorum: “Stratejik Atık Yönetim Merkezi / Atık Yönetimi Modülü”.

- Backend: Node.js + TypeScript
- Framework tercihi: NestJS veya Express (kurumsal yapıya daha uygun olanı öner ve kullan)
- Veritabanı: PostgreSQL
- Frontend: React + TypeScript
- UI: Modern, responsive, mobil uyumlu. Light/Dark theme desteği olacak (tema toggle).
- Çalışma ortamı: Ubuntu 22.04 / 24.04 üzerinde çalışacak. Tercihen Docker + docker-compose ile ayağa kalkabilmeli.

Bu modül, şimdilik bağımsız bir web uygulaması gibi davranacak ama canlıda kurumsal bir portala (Dijital İş Sitesi) SSO ile entegre olacak.

Elimde şu anda bir HTML/JS prototip var (Tailwind + React + lucide ikonları + localStorage mock DB ile yazılmış tek dosyalık bir demo ekran). Bu prototip, “Atık Yönetimi” sürecinin iş mantığını ve ekranlarını içeriyor:

- Saha personeli arayüzü (mobil uyumlu):
  - Lokasyon/oda QR kodu okuma
  - Atık türü seçimi (Tıbbi, Tehlikeli, Evsel, Geri Dönüşüm vb.)
  - Etiket oluşturma ve poşet/varile yapıştırma
  - Depoda kantar tartımı, barkod ile tartım bilgisi eşleştirme
  - Uygunsuzluk (hatalı ayrıştırma, teknik uygunsuzluk) bildirimi

- Hastane yöneticisi (manager) arayüzü:
  - Seçili hastane özelinde atık dağılımı
  - KPI ve performans kartları
  - Risk matrisi, operasyonel yük, zaman analizleri
  - Mahal kategorileri (Yoğun Bakım, Ameliyathane, Poliklinik vs.)
  - Parametre girişi (HBYS istatistikleri: yatış gün, ameliyat sayısı vb.)

- Genel Merkez (HQ) arayüzü:
  - Tüm hastaneleri gören merkezi dashboard
  - Hastane bazlı kıyaslama, benchmark
  - Karar destek ekranları, maliyet analizi, verimsizlik tespiti
  - Saha uygunsuzluk bildirimleri listesi ve detayları

Bu prototipin içinde:
- MOCK veritabanı `MockDB` (localStorage)
- Çok sayıda React component (RiskMatrix, RiskActionPanel, CostTable, TimeAnalysisChart, HospitalBenchmarking, AdvancedComparison, SettingsView, AnalyticsView, CollectorInterface, DashboardInterface vs.)
- `WASTE_TYPES`, `HOSPITALS`, `LOCATION_CATEGORIES`, `DEFAULT_LOCATIONS` gibi sabitler
- Kullanıcı rolleri: saha personeli, hastane yöneticisi, HQ

Bu mevcut HTML/JS prototipteki iş akışını ve mantığı **koruyarak** ama daha ölçeklenebilir, gerçek bir sistem olacak şekilde:
- PostgreSQL şeması,
- Backend API tasarımı,
- Frontend React mimarisi,
- SSO entegrasyon kancaları,
- Test ortamı kurgusu
oluşturmanı istiyorum.

Aşağıda mimari gereksinimleri detaylı anlatıyorum.

---

## MİMARİ ve ENTEGRASYON GEREKSİNİMLERİ

### 1. Kullanıcı & Hastane & Rol Entegrasyonu (Oracle / AD / SSO)

Canlıda şu hedef var:

- Kullanıcılar ve hastaneler zaten Oracle ERP ve Active Directory’de tanımlı.
- Dijital İş Sitesi denilen bir portal var:
  - Kullanıcı buraya kurumsal kullanıcı adı/şifre ile giriyor.
  - Portal üzerinden “Kurumsal Uygulamalar” menüsünden bizim modüle tıklıyor.
  - Olay Bildirimi vb. diğer uygulamalara şu an **tekrar login olmadan ve hastane seçtirmeden** girilebiliyor.
- Aynı davranışı bu Atık Yönetimi modülü için de istiyorum:
  - Portal, bizim modüle bir **auth token (SSO token)** ile gelecek.
  - Biz bu token’ı backend tarafında doğrulayacağız.
  - Kullanıcıyı tekrar login istemeden, otomatik olarak içeri alacağız.
  - Kullanıcının hastane bilgisi ve rolleri, Oracle/AD senkronundan veya token içinden gelecek.

Bu SSO mekanizmasının canlıda ne olduğuna dair net bilgi henüz yok (SAML / OIDC / custom JWT vb.). Bu nedenle:

- Test ortamı için **basit bir SSO simülasyonu** kurgulamak istiyorum:
  - “Fake Portal” (mini bir login sayfası) olacak.
  - Kullanıcı test portalına login olduktan sonra, modülün URL’sine yönlenecek.
  - Yönlendirirken URL parametresi veya header ile JWT token verecek.
  - JWT payload’ında en az şu alanlar olacak:
    - `sub` veya `user_id`
    - `username`
    - `email`
    - `hospital_code` (veya ID)
    - `roles` (örn. ["ISG_UZMANI", "HASTANE_YONETICI", "HQ"])
- Modülün backend’i bu JWT’yi doğrulayıp `/me` gibi bir endpoint üzerinden frontend’e oturum bilgisini dönecek.

Ayrıca:
- Oracle ERP ve AD’den kullanıcı/hastane/rol bilgilerinin periyodik (örn. 24 saatte bir) **senkronizasyonu** olacak:
  - Oracle/AD → (API üzerinden okuma) → Bizim PostgreSQL veri tabanı
  - Uygulama runtime’da sadece PostgreSQL’den okuyacak.

Bu senkron için canlıda gerçek Oracle/AD API’lerine bağlanacağız, ama test ortamında:
- Basit bir “fake Oracle/AD API” oluşturabiliriz:
  - `/oracle/users`, `/oracle/hospitals`, `/ad/roles` gibi endpointlerle JSON mock veri dönsün.
  - Backend’te bir `SyncService` bu verileri periyodik çekip PostgreSQL’e yazar (upsert).

### 2. Roller

Temel roller:

- **HQ (genel merkez)**:
  - Tüm hastaneleri görebilir.
  - Stratejik dashboard, kıyaslama, maliyet analizi, uygunsuzluk listeleri, sistem parametreleri.
- **Hastane Yöneticisi (manager)**:
  - Sadece kendi hastanesinin verilerini görür.
  - KPI’lar, risk matrisi, analizler ve kendi tesisi için parametre girişi.
- **Saha Personeli (collector)**:
  - Mobil arayüz (telefon/tablet).
  - Saha toplama, kantar/tartım, uygunsuzluk bildirimi.
  - Kendi adına işlem yapar ama raporlama tarafını görmez.

Token’daki `roles` + PostgreSQL’deki `user_roles` tablosu ile bu yetkiler kontrol edilecek.

---

## VERİ MODELİ (PostgreSQL)

Aşağıdaki gibi bir şema istiyorum (gerekirse genişletebilirsin):

### Temel Kurumsal Tablolar

- `users`
  - `id` (UUID, PK)
  - `external_id` (Oracle/AD user id)
  - `username`
  - `email`
  - `first_name`
  - `last_name`
  - `is_active`
  - `source_system` (enum: `oracle`, `ad`, `mixed`)
  - `created_at`, `updated_at`

- `hospitals`
  - `id` (UUID, PK)
  - `external_id` (Oracle hospital id)
  - `code` (ör: H1, H2 gibi kısa kod)
  - `name`
  - `is_active`
  - `created_at`, `updated_at`

- `roles`
  - `id` (UUID, PK)
  - `external_id` (AD group id veya Oracle role id)
  - `name` (ör: HQ, HOSPITAL_MANAGER, COLLECTOR, ISG_UZMANI vb.)
  - `description`

- `user_hospitals`
  - `id`
  - `user_id` (FK → users)
  - `hospital_id` (FK → hospitals)
  - `is_default`
  - `created_at`

- `user_roles`
  - `id`
  - `user_id` (FK → users)
  - `role_id` (FK → roles)
  - `created_at`

### Atık Yönetimi Spesifik Tablolar

- `waste_types`
  - `id`
  - `code` (medical, hazardous, domestic, recycle gibi)
  - `name`
  - `color_hex`
  - `cost_per_kg` (pozitif, geri dönüşüm için negatif olabilir)
  - `is_active`

- `location_categories`
  - `id`
  - `code` (icu, service, or, polyclinic, office, other)
  - `name`
  - `unit` (Yatış Gün, Ameliyat, Protokol, Personel vs.)
  - `reference_waste_factor` (ör: kg/Yatış Günü için referans değer)

- `locations` (QR ile eşleşen mahal – bu, prototipteki DEFAULT_LOCATIONS yapısına denk geliyor)
  - `id`
  - `hospital_id` (FK)
  - `code` (ör: AMELIYATHANE-ODA1)
  - `category_id` (FK → location_categories)
  - `custom_label` (ör: “Ana Bina 1. Kat”)
  - `is_active`

- `operational_coefficients` (HBYS istatistikleri – SettingsView’de girilen aylık değerler)
  - `id`
  - `hospital_id` (FK)
  - `category_id` (FK → location_categories)
  - `period` (ör: `2025-01` gibi year-month)
  - `value` (ör: aylık yatış gün sayısı, aylık ameliyat sayısı vs.)
  - `created_at`

- `waste_collections` (saha toplama + kantar sürecinin birleşik hali – her poşet/varil için bir kayıt)
  - `id`
  - `hospital_id` (FK)
  - `location_id` (FK)
  - `waste_type_id` (FK → waste_types)
  - `tag_code` (etiket barkodu, ör: TAG-XXXXXX)
  - `collected_by_user_id` (FK → users veya null (gelecekte Oracle’dan bağlanır))
  - `collected_at` (datetime)
  - `weighed_at` (datetime, null ise henüz tartılmamış)
  - `status` (enum: PENDING, COMPLETED, CANCELLED)
  - `weight_kg` (decimal)
  - `is_manual_weight` (boolean)
  - `created_at`, `updated_at`

- `issues` (uygunsuzluk bildirimleri)
  - `id`
  - `hospital_id` (FK)
  - `waste_collection_id` (FK, nullable – etiketsiz bildirim olabilir)
  - `tag_code` (null olabilir)
  - `category` (segregation, non_compliance gibi)
  - `description`
  - `reported_by_user_id` (FK → users)
  - `photo_url` (şimdilik nullable, gelecekte dosya yönetimi eklenebilir)
  - `reported_at`

- `sync_logs`
  - `id`
  - `source_system` (oracle, ad)
  - `sync_type` (full, incremental)
  - `status` (success, failed)
  - `started_at`, `finished_at`
  - `details` (jsonb – hata mesajları vs.)

Bu model, HTML prototipteki tüm iş akışlarını gerçek DB yapısına oturtacak.

---

## BACKEND BEKLENTİLERİ

Backend’ten beklediklerim:

1. Teknoloji:
   - Node.js + TypeScript
   - Tercihen NestJS (modüler yapı, DI, guard, scheduler vs. hazır gelsin)
   - TypeORM veya Prisma ile PostgreSQL entegrasyonu
2. Modüler yapı:
   - `auth` modülü
     - JWT doğrulama için guard/middleware
     - `/me` endpoint’i → token’dan kullanıcıyı tanı, PostgreSQL’den detaylarını çek, rol ve hastane atamalarını döndür.
     - Test ortamında “fake portal” ile basit shared secret’lı JWT kullan (ör: HMAC).
   - `users` modülü
   - `hospitals` modülü
   - `waste` modülü
     - `waste_collections` CRUD ve listeleme (filtreler: hastane, tarih aralığı, tür, lokasyon vb.)
     - Dashboard’a veri sağlayacak aggregate endpoint’ler (ör: toplam ağırlık, by type, by hospital, by category, by hour)
   - `settings` modülü
     - Lokasyon kategorileri + mahaller (locations)
     - Operasyonel katsayılar (operational_coefficients)
   - `issues` modülü
   - `sync` modülü
     - Fake Oracle/AD API’lerine istek atan servisler
     - 24 saatte bir senkron işleri (NestJS Schedule veya node-cron)
3. Test SSO entegrasyonu:
   - “Fake portal” modülü ya da ayrı mini servis:
     - Basit bir login formu olsun (username/password hard-coded bile olabilir).
     - Login sonrası JWT üretip frontend URL’sine redirect etsin (örn. `http://localhost:5173/?token=...`).
   - Backend auth guard:
     - Token’ı header veya query param’dan al.
     - Secret ile doğrula.
     - `req.user` içine decoded payload + veritabanı bulgularını koy.
4. API tasarımı:
   - `/auth/me`
   - `/waste/collections` (GET – liste, POST – yeni kayıt, PATCH – güncelle vb.)
   - `/waste/dashboard/summary` → Atık türü dağılımı, toplam kg, bekleyen/işlenen sayılar vb.
   - `/waste/dashboard/risk-matrix` → RiskMatrix bileşeninin ihtiyacı olan veri
   - `/waste/dashboard/cost` → CostTable için veri
   - `/waste/dashboard/time` → saat bazlı analiz için veri
   - `/settings/locations`
   - `/settings/operational-coefficients`
   - `/issues` (liste + create)
   - `/sync/run` (test ortamında manuel tetiklemek için)

Kritik nokta:  
HTML prototipte frontende gömülü olan hesaplama mantıklarının (risk matrisi, VPN benzeri score hesapları, KPI’lar, verimsizlik maliyeti hesapları vb.) **büyük kısmını backend tarafına taşımanı tercih ederim**. Frontend mümkün olduğunca “rendering + basit UI mantığı” ile uğraşsın.

---

## FRONTEND (REACT + TYPESCRIPT) BEKLENTİLERİ

1. Teknoloji:
   - React + TypeScript
   - Modern component yapısı (functional, hooks)
   - State management için:
     - Tercihen React Query (server state) + minimal context.
   - UI:
     - TailwindCSS kullanılabilir.
     - Mobile-first tasarım (özellikle saha personeli modülü için).
     - Light/Dark theme toggle (tercihen context veya `useTheme` tarzında).
2. Sayfalar / Layout’lar:
   - `AuthLayout`:
     - İlk açılışta backend `/me` çağrısı yaparak kullanıcı oturumunu doğrular.
     - Token URL’den bir kez alınır, localStorage veya cookie’de tutulabilir (test ortamında).
   - `Dashboard (HQ)`:
     - Genel göstergeler (toplam atık, tıbbi oran, bekleyen/işlenen vb.)
     - Atık türü donut chart
     - Hastane bazlı bar chart
     - Canlı operasyon akışı tablosu
   - `Analytics`:
     - Tablar: Hastane KPI (HospitalBenchmarking), Risk Matrix, Cross Comparison, Cost, Time Analysis
   - `Settings`:
     - Mahaller ve kategoriler
     - Operasyonel veri giriş ekranı (HBYS’den alınacak sayılar)
   - `Issues`:
     - Bildirilen uygunsuzlukların listesi, filtreler, detay
   - `Collector UI` (mobil):
     - Menü (Saha Topla, Kantar/Tartım, Uygunsuzluk Bildirimi)
     - Saha toplama akışı (lokasyon seç/QR oku, atık türü seç, etiket göster)
     - Kantar akışı (barkod oku, ağırlık al, manuel giriş, kaydı tamamla)
     - Uygunsuzluk bildirimi (kategori, açıklama, barkod, foto placeholder)

3. Prototip HTML’deki iş akışı ve ekranlar:
   - Tasarımsal ve UX olarak büyük oranda korunabilir.
   - Ama data ve state, localStorage yerine gerçek API’lerden gelsin.
   - Mock hesaplamalar (ör: risk scoring) backend’den gelen aggregate veriye göre yapılsın.

---

## TEST ORTAMI

İstediğim şey:

- Tüm bu sistemi tek bir `docker-compose.yml` ile ayağa kaldırabilmek:
  - `postgres`
  - `backend` (NestJS veya Express TS)
  - `frontend` (React, build edilmiş ve Nginx ile serve edilebilir)
  - `fake-portal` (opsiyonel, küçük bir Node/React login sayfası)
  - `fake-oracle-ad` (opsiyonel, simple JSON API)

Test senaryosu:

1. `docker-compose up` ile tüm sistem ayağa kalksın.
2. Tarayıcıdan `http://localhost:3001` (fake portal) açılır.
3. Test kullanıcıyla login olurum.
4. Portal beni `http://localhost:3000` (frontend) adresine token ile yönlendirir.
5. Frontend backend’e `/auth/me` çağrısı atar, oturum doğrulanır, roller/hastane bilgisi çekilir.
6. Dashboard açılır, Oracle/AD’den sync ile gelen mock kullanıcı/hastane/rol bilgileri üzerinden atık kayıtları ve analizler görüntülenir.
7. Saha modülü ekranından birkaç atık kaydı girerim, tartım yaparım, uygunsuzluk bildiririm.
8. HQ veya Hastane Yöneticisi ekranından bu verileri analiz ederim.

---

## İSTEDİĞİM ÇIKTILAR

Bu prompt’a cevaben Replit’te senden şunları istiyorum:

1. **Mimari özet dokümanı (kısa):**
   - Kullandığın backend framework’ü, ORM’yi, frontend yapısını ve modülleri özetle.
2. **PostgreSQL şema taslağı:**
   - Tablolar ve ilişkiler (DDL’i tamamen yazmana gerek yok, ama mümkünse SQL taslağı ver).
3. **Backend iskeleti:**
   - Klasör yapısı (src/modules/… gibi)
   - Önemli modüller, entity/model tanımları, temel controller/service iskeletleri
   - Özellikle `/auth/me`, `/waste/dashboard/*`, `/waste/collections`, `/settings/*`, `/issues` endpoint’lerinin arayüzünü göster.
4. **Frontend iskeleti:**
   - Sayfa yapısı, routing (örn. React Router)
   - Global layout (sidebar, navbar, theme toggle)
   - Saha modülü için ayrı bir route (örn. `/mobile` veya rol tabanlı UI switch)
5. **Test SSO ve fake Oracle/AD için mantık:**
   - Basit JWT üretimi ve doğrulama
   - Senkron servislerinin nasıl tetikleneceği (manuel + cron)

Kodları tam üretmen gerekmiyor ama mümkün olduğunca gerçekçi ve kullanılabilir TypeScript/React/NestJS iskeletleri vermeni istiyorum.  
Öncelik: **Mimari ve veri modeli + temel endpoint ve component iskeletleri**.  
UI detaylarını, stilleri ve gelişmiş grafikleri sonraki iterasyonlarda birlikte rafine edebiliriz.